Author: Михайлов Никита Маратович
Group: 161
The flag is: HSE{T0_T3a_0r_n0t_t0_t3a}
Password is: TheP@zzzzwordIsWayTooL0ngT0Hack?

Заметим, что кодировка происходит блоками по 8 байт, то есть
кодируются пары (uint32_t, uint32_t). После кодировки всей
строки в конец добавляются лишние 8 байт, которые берутся
в результате кодировки рандомной строки из массива integrity_check_suffix.
Ее добавляют для проверки дешифровки. Если конец зашифрованного послания
дешифруется не как одна из проверочных строк, значит что-то пошло не так.
Это нам позволяет сгенерировать ключи, подходящие для дешифровки.


Зная исходые строки и результат:
    1) мы можем получить результат xor'a
    некоторых частей ключа. Далее мы создаем такие ключи, чтобы при xor'e
    было то, что нужно. Причем первые 2 ключа подбираются точно, но 
    последние 2 нет. Из-за того, что в них важны только первые 3 бита.
    2) Перебрать 2**12 = 2**8 * 2**3 + 2**8 * 2**3 вариантов.
    Сначала подобрать key[1], key[3], так как для дешифровки 
    второго байта используются только они, а потом уже перебрать
    key[0] и key[2]
    3) Перебрать 2**22 = 2**8 * 2**3 * 2**8 * 2**3 вариантов, то есть
    все имеющие смысл биты ключей

Как пользоваться скриптом:
    Вводим туда зашифрованный текст
    Получаем ключ
    Получаем текст, который был дешифрован с этим ключом
    (но если там что-то сломалось, то можно ключ вставить в decrypt.py)

Что из себя представляет скрипт:
    В нем есть скопированные из encrypt.py и decrypt.py
    функции для работы с байтами. Есть 3 версии подбора ключей.
    Методы для подбора -- find_key_vN(before_pair, after_pair)
    v1 -- самая быстрая за О(1). Явно считаем ключ
    v2 -- перебор 2**12 вариантов
    v3 -- перебор 2**22 вариантов

    Сначала вызывается v1. Если ключей нет или дешифровка неуспешна,
    то вызывается v2, далее, аналогично, v3. Если и в таком случае
    ключей нет, то вход плохой.
